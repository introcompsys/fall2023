# Design a CLI tool 

Today you will apply what we learned about the unix philosophy to *design*, but not implement, a command line tool. 

Notes: 
- **read through this whole issue before you start working**
- You may work with a classmate on your design
- Your reflection must be individual
- There are some extra things in the notes that we did not get to in class yesterday that might be helpful
- it is okay if you do not finish the whole design, just be sure to answer the reflection questions.
- if you are motivated to actually build the tool you design today, you can submit a bulid badge proposal to do it. 

## Decide what your tool will do

Some ideas: 
- calculate grade in class
- manage a todo list
- badge formatting checker (that would run in a GitHub Action)



## Design Process

Questions to consider in your design process: 
- what information do you need
- what calculations need to occur
- what can be done with existing tools we have seen (you do not need to consider what can be done with any tool ever invented)

Within your designed command line tool: 
- what command(s) will you have?
- what arguments (required inputs) will you have?
- what option(s) (optional inputs) will you have? 
- what utility functions would enable your tool to not have any duplicated code? 


## Checkout

Template for `lab5.md`:

In the design section you can choose:
- write what the help for your command(s) would look like
- if programming syntax is helpful you can write function def/API lines with the parameters and plain english that describes the inputs
- if you do not finish your design, you can put whatever notes about progress that you make

```
# Lab 5 

<!-- one sentence/phrase about what your tool does -->

<!-- collaborator if applicable -->

## Use case

<!-- write a bash line that shows how you would use your command with existing commands and pipes -->


## Design





## Reflection

1. How did this exercise impact your understanding of the unix philosophy?
1. How did this planning exercise compare to your past experiences with planning out code? 
1. What is the most important thing you learned in this lab? 
1. Would you recommend this lab activity be reused? (yes/no/or suggested changes are welcome)

```

